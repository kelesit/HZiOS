### 屏幕显示图像的原理  

#### VSync和HSync信号  

CRT(阴极射线显示管)有个电子枪的部件，会从上到下一行行的扫描，知道整屏幕扫描完毕，一帧的图像就会被显示出来；其中有两个时间点：（1）扫描到屏幕的最后一行（2）开始扫描屏幕的行

+ VSync：一帧的画面绘制完成，电子枪要复位发出的信号
+ HSync：电子枪准备进行扫描发出的信号


#### CPU和GPU合作绘制图像的过程  

CPU将计算好的内容提交给GPU，GPU进行合成和纹理的渲染后将结果提交到帧缓冲区（FrameBuffer）；视频控制器根据VSync信号逐行从帧缓冲区中读取数据，然后通过数模转换交给显示器呈现；


### UI卡顿和解决方案

#### UI卡顿产生的原因  

VSync信号到来（16.7ms）CPU和GPU没有将绘制的结果放到帧缓冲区中，那么这一帧就会被丢弃，等待下一次机会显示，而现在屏幕保持的是之前显示的内容，这就是卡顿产生的原因

#### CPU资源消耗原因和解决方案  

+ 对象创建
  - 通过代码创建UI要比storyboard高效
  - 不涉及UI的操作可以放到后台线程中处理
  - 考虑懒加载和对象的复用机制
+ 对象调整
  - 避免创建视图后属性的动态调整，因为CALayer中没有属性，当调整属性时是根据运行时`resolveInstanceMethod`为对象临时添加方法，并把属性放在dictionary中的
  - 减少视图层级的调整，视图层级调整会触发UIView和CALayer很多方法调用与通知
+ 对象销毁： 注意创建对象在不使用后及时销毁
+ 布局计算 ：后台线程预先进行布局计算，并缓存已经计算好的布局
+ AutoLayout ： 界面组件布局复杂时，autoLayout在性能上就会表现的很差
+ 文本计算： 通常用在计算文本的宽高上，可以使用`[NSAttributedString boundingRectWithSize:options:context:]`计算文本的宽高
+ 文本渲染：显示大量文本时可以考虑TextKit或CoreText
+ 图片的解码：常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片
+ 图像的绘制：采用异步绘制的方式；

#### GPU资源消耗原因和解决方案  

+ 视图的混合：多个视图重叠显示，GPU会把他们混合到一起，页面布局复杂或层级较多就会使GPU消耗过多的资源
+ 避免使用圆角、阴影、遮罩等属性


### 列表优化方式  

+ 预排版：通过API获取JSON数据后在后台线程创建封装每个model对应的CellLayout（Cell内部每个控件的高度，cell的整体高度等）这样对于tableView来说在使用高度函数时就避免了再次计算
+ 预渲染：针对某些控件要渲染为圆形
+ 异步绘制
+ 全局并发控制：大量concurrent queue的创建、销毁也会占用CPU资源
+ 更高效的异步图片加载

